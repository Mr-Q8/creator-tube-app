// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Automates the re-execution of a Colab script with different parameters based on the results of the previous run.
 *
 * - colabLoopAutomation - A function that manages the loop automation process.
 * - ColabLoopAutomationInput - The input type for the colabLoopAutomation function.
 * - ColabLoopAutomationOutput - The return type for the colabLoopAutomation function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { runColabNotebook } from '@/services/colab';

const ColabLoopAutomationInputSchema = z.object({
  parameters: z.string().describe('The parameters to pass to the Colab notebook as a stringified JSON.'),
  previousResults: z.string().optional().describe('The results from the previous Colab notebook run, if any.'),
  maxIterations: z.number().int().min(1).default(3).describe('The maximum number of iterations to run the Colab notebook.'),
  iterationCount: z.number().int().min(0).default(0).describe('The current iteration count.')
});
export type ColabLoopAutomationInput = z.infer<typeof ColabLoopAutomationInputSchema>;

const ColabLoopAutomationOutputSchema = z.object({
  shouldRerun: z.boolean().describe('Whether the Colab notebook should be rerun with different parameters.'),
  newParameters: z.string().optional().describe('The new parameters to use for the next Colab notebook run, as a stringified JSON.'),
  reason: z.string().describe('The reason for the decision to rerun or not.'),
  videoUrl: z.string().url().optional().describe('The URL of the generated video, if available.'),
});
export type ColabLoopAutomationOutput = z.infer<typeof ColabLoopAutomationOutputSchema>;

export async function colabLoopAutomation(input: ColabLoopAutomationInput): Promise<ColabLoopAutomationOutput> {
  return colabLoopAutomationFlow(input);
}

const shouldRerunColabTool = ai.defineTool(
  {
    name: 'shouldRerunColab',
    description: 'Determines whether the Colab notebook should be rerun with different parameters based on the previous results and iteration count.',
    inputSchema: z.object({
        parameters: z.string().describe('The parameters used for the Colab notebook run, as a stringified JSON.'),
        previousResults: z.string().optional().describe('The results from the previous Colab notebook run, if any.'),
        maxIterations: z.number().int().describe('The maximum number of iterations to run the Colab notebook.'),
        iterationCount: z.number().int().describe('The current iteration count.'),
    }),
    outputSchema: z.object({
        shouldRerun: z.boolean().describe('Whether the Colab notebook should be rerun with different parameters.'),
        newParameters: z.string().optional().describe('The new parameters to use for the next Colab notebook run, as a stringified JSON.'),
        reason: z.string().describe('The reason for the decision to rerun or not.'),
    }),
  },
  async (input): Promise<{shouldRerun: boolean; newParameters?: string; reason: string;}> => {
    
    // Stop iterating if we've reached the max.
    if (input.iterationCount >= input.maxIterations - 1) {
      return {
          shouldRerun: false,
          reason: `Se alcanzó el máximo de iteraciones (${input.maxIterations}). Generando video final.`,
      };
    }

    // This is a placeholder for a real check on results quality
    if (input.previousResults) {
        try {
            const prevResultsParsed = JSON.parse(input.previousResults);
            // This is a dummy check. Real logic would analyze prevResultsParsed content.
            if (prevResultsParsed.success === true) {
                 return {
                    shouldRerun: false,
                    reason: 'El notebook de Colab se ejecutó exitosamente. Deteniendo el ciclo.',
                };
            }
        } catch {
            // ignore parsing errors
        }
    }
    
    // Default case: continue rerunning
    const currentParams = JSON.parse(input.parameters);
    const newIteration = (currentParams.iteration || 1) + 1;
    
    // This is where a more sophisticated AI prompt could generate a better prompt
    const newPrompt = `Un video corto e inspirador sobre los beneficios transformadores para la salud mental y el bienestar, con imágenes visualmente relajantes y una música tranquila. Iteración ${newIteration}.`;

    return {
        shouldRerun: true,
        newParameters: JSON.stringify({ 
            ...currentParams,
            prompt: newPrompt,
            iteration: newIteration,
        }),
        reason: input.previousResults 
            ? `Resultados previos no fueron óptimos. Refinando el prompt para la iteración ${newIteration}.`
            : 'La cuenta de iteraciones es inferior a la cuenta máxima. Se volverá a ejecutar Colab con un prompt refinado para mejorar el video.'
    };
  }
);

const colabLoopAutomationFlow = ai.defineFlow(
  {
    name: 'colabLoopAutomationFlow',
    inputSchema: ColabLoopAutomationInputSchema,
    outputSchema: ColabLoopAutomationOutputSchema,
  },
  async input => {
    // 1. Decide if we need to rerun
    const decision = await shouldRerunColabTool(input);

    // 2. If we are NOT rerunning, it's time to generate the video
    if (!decision.shouldRerun) {
        try {
            const finalParams = JSON.parse(input.parameters);
            const videoResult = await runColabNotebook(finalParams);
            return {
                ...decision,
                videoUrl: videoResult.videoUrl, // Add the video URL to the final output
            };
        } catch (e: any) {
            // If video generation fails, return the decision without a URL
            return {
                ...decision,
                reason: `${decision.reason} Error al generar el video final: ${e.message}`,
            };
        }
    }

    // 3. If we ARE rerunning, just return the decision as is.
    return {
        ...decision,
    };
  }
);

    